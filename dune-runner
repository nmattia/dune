#!/usr/bin/env bash

set -euo pipefail

# DUNE_ROOT: the sandbox root. Anything higher up will be denied access.
dune_root="${DUNE_ROOT:?No DUNE_ROOT}"
unset DUNE_ROOT

# DUNE_UNTRUSTED_PATH: colon-separated list of directories to sandbox
dune_untrusted_path="${DUNE_UNTRUSTED_PATH:?No DUNE_UNTRUSTED_PATH}"
unset DUNE_UNTRUSTED_PATH

# DUNE_SANDBOXER: path to sandboxer
dune_sandboxer="${DUNE_SANDBOXER:?No DUNE_SANDBOXER}"
unset DUNE_SANDBOXER

# DUNE_SANDBOX_DIR: TODO
dune_sandbox_dir="${DUNE_SANDBOX_DIR:?No DUNE_SANDBOX_DIR}"
unset DUNE_SANDBOX_DIR

# DUNE_EXE_NAME: TODO: doc + add default?
dune_exe_name="${DUNE_EXE_NAME:?No DUNE_EXE_NAME}"
unset DUNE_EXE_NAME

# remove the sandbox path from the PATH so that
# executables can call the un-sandboxed exes (top-level is still
# sandboxed). Nested sandboxing is an error.
PATH="${PATH#"${dune_sandbox_dir}":?}" # remove "$dune_sandbox_dir" from "$PATH"

exe="$(PATH="$dune_untrusted_path" command -v "$dune_exe_name")"

# DUNE_ENV_FOO: environment to set in the sandbox
# Read NUL-delimited env vars: DUNE_ENV_FOO=hello, world!
while IFS= read -r -d '' rec; do
    [[ $rec == DUNE_ENV_*=* ]] || continue

    name_full=''${rec%%=*}          # "DUNE_ENV_FOO"
    val=''${rec#*=}                 # "hello, world!"
    name=''${name_full#DUNE_ENV_}   # "FOO"

    unset "$name_full"

    export "$name=$val"
done < <(env -0)

# make unsandboxed bins available
PATH="$dune_untrusted_path:$PATH"

exec -a "$dune_exe_name" "$dune_sandboxer" --root "$dune_root" --home "$HOME" -- "$exe" "$@"
